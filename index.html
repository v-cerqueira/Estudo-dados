<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estrutura de Dados - Material Completo</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/animations.css">
    <link rel="stylesheet" href="css/quiz.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-content">
            <div class="loading-logo">
                <i class="fas fa-brain"></i>
            </div>
            <div class="loading-text">Carregando Material Completo</div>
            <div class="loading-bar">
                <div class="loading-progress"></div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <i class="fas fa-brain"></i>
                <span>Estrutura de Dados</span>
            </div>
            <div class="nav-menu" id="nav-menu">
                <a href="#home" class="nav-link active">Home</a>
                <a href="#conceitos" class="nav-link">Conceitos</a>
                <a href="#estruturas" class="nav-link">Estruturas</a>
                <a href="#exercicios" class="nav-link">Exercícios</a>
                <a href="#prova" class="nav-link">Prova</a>
                <a href="#resumo" class="nav-link">Resumo</a>
            </div>
            <div class="nav-toggle" id="nav-toggle">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Hero Section -->
        <section id="home" class="hero-section">
            <div class="hero-background">
                <div class="hero-grid"></div>
                <div class="hero-particles"></div>
            </div>
            <div class="hero-content">
                <h1 class="hero-title">
                    <span class="title-line">Estrutura de</span>
                    <span class="title-line highlight">Dados</span>
                </h1>
                <p class="hero-subtitle">Material Completo - 2º Bimestre - Preparação para Prova</p>
                <div class="hero-stats">
                    <div class="stat-item">
                        <i class="fas fa-book"></i>
                        <span>6 Estruturas</span>
                    </div>
                    <div class="stat-item">
                        <i class="fas fa-code"></i>
                        <span>50+ Exercícios</span>
                    </div>
                    <div class="stat-item">
                        <i class="fas fa-question-circle"></i>
                        <span>200 Questões</span>
                    </div>
                    <div class="stat-item">
                        <i class="fas fa-graduation-cap"></i>
                        <span>4 Níveis</span>
                    </div>
                </div>
                <div class="hero-actions">
                    <button class="btn btn-primary" onclick="scrollToSection('conceitos')">
                        <i class="fas fa-rocket"></i>
                        Começar
                    </button>
                    <button class="btn btn-secondary" onclick="scrollToSection('prova')">
                        <i class="fas fa-clipboard-check"></i>
                        Fazer Prova
                    </button>
                </div>
            </div>
        </section>

        <!-- Conceitos Section -->
        <section id="conceitos" class="section">
            <div class="container">
                <div class="section-header">
                    <h2 class="section-title">Conceitos Fundamentais</h2>
                    <p class="section-subtitle">Base teórica essencial para entender estruturas de dados</p>
                </div>
                
                <div class="concepts-grid">
                    <div class="concept-card" data-aos="fade-up">
                        <div class="card-icon">
                            <i class="fas fa-database"></i>
                        </div>
                        <h3>Dados</h3>
                        <p>Elementos brutos e isolados que representam aspectos da realidade. São a matéria-prima que, quando processada, se transforma em informação útil.</p>
                        <div class="card-details">
                            <strong>Características:</strong>
                            <ul>
                                <li>Representam fatos ou observações</li>
                                <li>Podem ser processados por computadores</li>
                                <li>São a base para a informação</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="concept-card" data-aos="fade-up" data-aos-delay="100">
                        <div class="card-icon">
                            <i class="fas fa-layer-group"></i>
                        </div>
                        <h3>Estruturas Homogêneas</h3>
                        <p>Armazenam apenas um tipo de dado. Todos os elementos têm o mesmo tipo e tamanho.</p>
                        <div class="card-details">
                            <strong>Exemplos:</strong>
                            <ul>
                                <li>Vetor de inteiros: int numeros[10]</li>
                                <li>Array de caracteres: char nome[50]</li>
                                <li>Matriz de float: float notas[5][3]</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="concept-card" data-aos="fade-up" data-aos-delay="200">
                        <div class="card-icon">
                            <i class="fas fa-cubes"></i>
                        </div>
                        <h3>Estruturas Heterogêneas</h3>
                        <p>Armazenam diferentes tipos de dados em uma única estrutura.</p>
                        <div class="card-details">
                            <strong>Exemplos:</strong>
                            <ul>
                                <li>Struct em C</li>
                                <li>Registros</li>
                                <li>Classes (em POO)</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="concept-card" data-aos="fade-up" data-aos-delay="300">
                        <div class="card-icon">
                            <i class="fas fa-vector-square"></i>
                        </div>
                        <h3>Vetores (Arrays)</h3>
                        <p>Estrutura de dados linear com elementos armazenados em posições contínuas da memória.</p>
                        <div class="card-details">
                            <strong>Características:</strong>
                            <ul>
                                <li>Acesso direto por índice</li>
                                <li>Memória contínua</li>
                                <li>Tamanho fixo</li>
                                <li>Alto custo para inserção/remoção no meio</li>
                            </ul>
                        </div>
                    </div>

                    <div class="concept-card" data-aos="fade-up" data-aos-delay="400">
                        <div class="card-icon">
                            <i class="fas fa-table"></i>
                        </div>
                        <h3>Matrizes</h3>
                        <p>Estrutura de dados bidimensional organizada em linhas e colunas.</p>
                        <div class="card-details">
                            <strong>Aplicações:</strong>
                            <ul>
                                <li>Representação de imagens</li>
                                <li>Tabelas de dados</li>
                                <li>Jogos (tabuleiros)</li>
                                <li>Processamento de sinais</li>
                            </ul>
                        </div>
                    </div>

                    <div class="concept-card" data-aos="fade-up" data-aos-delay="500">
                        <div class="card-icon">
                            <i class="fas fa-memory"></i>
                        </div>
                        <h3>Alocação de Memória</h3>
                        <p>Processo de reservar espaço na memória para armazenar dados.</p>
                        <div class="card-details">
                            <strong>Tipos:</strong>
                            <ul>
                                <li><strong>Estática:</strong> Tamanho definido em compilação</li>
                                <li><strong>Dinâmica:</strong> Tamanho definido em execução</li>
                                <li><strong>Stack:</strong> Variáveis locais</li>
                                <li><strong>Heap:</strong> malloc/free</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Estruturas Section -->
        <section id="estruturas" class="section">
            <div class="container">
                <div class="section-header">
                    <h2 class="section-title">Estruturas de Dados</h2>
                    <p class="section-subtitle">As principais estruturas e suas implementações</p>
                </div>
                
                <div class="structures-tabs">
                    <div class="tab-buttons">
                        <button class="tab-btn active" data-tab="listas">
                            <i class="fas fa-link"></i>
                            Listas
                        </button>
                        <button class="tab-btn" data-tab="pilhas">
                            <i class="fas fa-layer-group"></i>
                            Pilhas
                        </button>
                        <button class="tab-btn" data-tab="filas">
                            <i class="fas fa-stream"></i>
                            Filas
                        </button>
                        <button class="tab-btn" data-tab="arvores">
                            <i class="fas fa-tree"></i>
                            Árvores
                        </button>
                        <button class="tab-btn" data-tab="grafos">
                            <i class="fas fa-project-diagram"></i>
                            Grafos
                        </button>
                        <button class="tab-btn" data-tab="comparacao">
                            <i class="fas fa-chart-bar"></i>
                            Comparação
                        </button>
                    </div>
                    
                    <div class="tab-content">
                        <div id="listas" class="tab-pane active">
                            <div class="structure-content">
                                <div class="structure-info">
                                    <h3>Listas Encadeadas</h3>
                                    <div class="structure-details">
                                        <h4>Características:</h4>
                                        <ul>
                                            <li>Cada nó contém valor + ponteiro</li>
                                            <li>Elementos não contínuos na memória</li>
                                            <li>Tamanho dinâmico</li>
                                            <li>Inserção/remoção eficiente</li>
                                            <li>Sem acesso direto por índice</li>
                                        </ul>
                                        
                                        <h4>Tipos:</h4>
                                        <ul>
                                            <li><strong>Simples:</strong> Um ponteiro por nó</li>
                                            <li><strong>Dupla:</strong> Dois ponteiros por nó</li>
                                            <li><strong>Circular:</strong> Último aponta para o primeiro</li>
                                        </ul>

                                        <h4>Operações Principais:</h4>
                                        <ul>
                                            <li>Inserção no início/final/meio</li>
                                            <li>Remoção de elementos</li>
                                            <li>Busca de elementos</li>
                                            <li>Inversão da lista</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="structure-code">
                                    <h4>Estrutura Básica:</h4>
                                    <pre><code>typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Funções principais
Node* createNode(int value);
void insertAtBeginning(Node** head, int value);
void insertAtEnd(Node** head, int value);
void deleteNode(Node** head, int value);
void printList(Node* head);
int searchNode(Node* head, int value);</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div id="pilhas" class="tab-pane">
                            <div class="structure-content">
                                <div class="structure-info">
                                    <h3>Pilhas (LIFO)</h3>
                                    <div class="structure-details">
                                        <h4>Princípio:</h4>
                                        <p><strong>LIFO:</strong> Last In, First Out (último a entrar, primeiro a sair)</p>
                                        
                                        <h4>Operações:</h4>
                                        <ul>
                                            <li><strong>PUSH:</strong> Empilhar elemento</li>
                                            <li><strong>POP:</strong> Desempilhar elemento</li>
                                            <li><strong>PEEK/TOP:</strong> Ver elemento do topo</li>
                                            <li><strong>ISEMPTY:</strong> Verificar se está vazia</li>
                                            <li><strong>ISFULL:</strong> Verificar se está cheia</li>
                                        </ul>

                                        <h4>Aplicações:</h4>
                                        <ul>
                                            <li>Chamadas de função (call stack)</li>
                                            <li>Desfazer operações (undo)</li>
                                            <li>Avaliação de expressões</li>
                                            <li>Navegação em navegadores</li>
                                            <li>Verificação de parênteses</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="structure-code">
                                    <h4>Implementação com Vetor:</h4>
                                    <pre><code>#define MAX 100
typedef struct {
    int data[MAX];
    int top;
} Stack;

void initStack(Stack* s) {
    s->top = -1;
}

void push(Stack* s, int value) {
    if (s->top < MAX-1) {
        s->data[++s->top] = value;
    }
}

int pop(Stack* s) {
    if (s->top >= 0) {
        return s->data[s->top--];
    }
    return -1; // erro
}

int peek(Stack* s) {
    if (s->top >= 0) {
        return s->data[s->top];
    }
    return -1;
}</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div id="filas" class="tab-pane">
                            <div class="structure-content">
                                <div class="structure-info">
                                    <h3>Filas (FIFO)</h3>
                                    <div class="structure-details">
                                        <h4>Princípio:</h4>
                                        <p><strong>FIFO:</strong> First In, First Out (primeiro a entrar, primeiro a sair)</p>
                                        
                                        <h4>Operações:</h4>
                                        <ul>
                                            <li><strong>ENQUEUE:</strong> Enfileirar elemento</li>
                                            <li><strong>DEQUEUE:</strong> Desenfileirar elemento</li>
                                            <li><strong>FRONT:</strong> Ver primeiro elemento</li>
                                            <li><strong>REAR:</strong> Ver último elemento</li>
                                            <li><strong>ISEMPTY:</strong> Verificar se está vazia</li>
                                        </ul>

                                        <h4>Tipos:</h4>
                                        <ul>
                                            <li><strong>Simples:</strong> Implementação básica</li>
                                            <li><strong>Circular:</strong> Reutiliza espaços vazios</li>
                                            <li><strong>Prioridade:</strong> Elementos com prioridade</li>
                                            <li><strong>Dupla:</strong> Inserção/remoção nas duas extremidades</li>
                                        </ul>

                                        <h4>Aplicações:</h4>
                                        <ul>
                                            <li>Fila de pessoas</li>
                                            <li>Fila de impressão</li>
                                            <li>Buffers de rede</li>
                                            <li>Filas de processos</li>
                                            <li>Sistemas de atendimento</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="structure-code">
                                    <h4>Fila Circular:</h4>
                                    <pre><code>#define MAX 10
typedef struct {
    int data[MAX];
    int front, rear;
    int size;
} Queue;

void initQueue(Queue* q) {
    q->front = 0;
    q->rear = -1;
    q->size = 0;
}

void enqueue(Queue* q, int value) {
    if (!isFull(q)) {
        q->rear = (q->rear + 1) % MAX;
        q->data[q->rear] = value;
        q->size++;
    }
}

int dequeue(Queue* q) {
    if (!isEmpty(q)) {
        int value = q->data[q->front];
        q->front = (q->front + 1) % MAX;
        q->size--;
        return value;
    }
    return -1;
}</code></pre>
                                </div>
                            </div>
                        </div>

                        <div id="arvores" class="tab-pane">
                            <div class="structure-content">
                                <div class="structure-info">
                                    <h3>Árvores</h3>
                                    <div class="structure-details">
                                        <h4>Características:</h4>
                                        <ul>
                                            <li>Estrutura hierárquica</li>
                                            <li>Um nó raiz</li>
                                            <li>Nós filhos e pais</li>
                                            <li>Nós folha (sem filhos)</li>
                                        </ul>
                                        
                                        <h4>Tipos:</h4>
                                        <ul>
                                            <li><strong>Árvore Binária:</strong> Máximo 2 filhos</li>
                                            <li><strong>Árvore Binária de Busca:</strong> Ordenada</li>
                                            <li><strong>Árvore AVL:</strong> Balanceada</li>
                                            <li><strong>Heap:</strong> Árvore de prioridade</li>
                                        </ul>

                                        <h4>Percursos:</h4>
                                        <ul>
                                            <li><strong>Pré-ordem:</strong> Raiz → Esquerda → Direita</li>
                                            <li><strong>Em-ordem:</strong> Esquerda → Raiz → Direita</li>
                                            <li><strong>Pós-ordem:</strong> Esquerda → Direita → Raiz</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="structure-code">
                                    <h4>Estrutura de Nó:</h4>
                                    <pre><code>typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// Funções básicas
TreeNode* createNode(int value);
void insertNode(TreeNode** root, int value);
TreeNode* searchNode(TreeNode* root, int value);
void inorderTraversal(TreeNode* root);
void preorderTraversal(TreeNode* root);
void postorderTraversal(TreeNode* root);</code></pre>
                                </div>
                            </div>
                        </div>

                        <div id="grafos" class="tab-pane">
                            <div class="structure-content">
                                <div class="structure-info">
                                    <h3>Grafos</h3>
                                    <div class="structure-details">
                                        <h4>Características:</h4>
                                        <ul>
                                            <li>Conjunto de vértices e arestas</li>
                                            <li>Representa relacionamentos</li>
                                            <li>Estrutura não-linear</li>
                                        </ul>
                                        
                                        <h4>Tipos:</h4>
                                        <ul>
                                            <li><strong>Dirigido:</strong> Arestas com direção</li>
                                            <li><strong>Não-dirigido:</strong> Arestas sem direção</li>
                                            <li><strong>Ponderado:</strong> Arestas com peso</li>
                                            <li><strong>Cíclico/Acíclico:</strong> Com/sem ciclos</li>
                                        </ul>

                                        <h4>Representações:</h4>
                                        <ul>
                                            <li><strong>Matriz de Adjacência:</strong> O(n²)</li>
                                            <li><strong>Lista de Adjacência:</strong> O(V+E)</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="structure-code">
                                    <h4>Matriz de Adjacência:</h4>
                                    <pre><code>#define MAX_VERTICES 100

typedef struct {
    int vertices;
    int adjMatrix[MAX_VERTICES][MAX_VERTICES];
} Graph;

void initGraph(Graph* g, int vertices) {
    g->vertices = vertices;
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            g->adjMatrix[i][j] = 0;
        }
    }
}

void addEdge(Graph* g, int src, int dest) {
    g->adjMatrix[src][dest] = 1;
    g->adjMatrix[dest][src] = 1; // Para grafo não-dirigido
}</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div id="comparacao" class="tab-pane">
                            <div class="comparison-table">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Estrutura</th>
                                            <th>Princípio</th>
                                            <th>Acesso</th>
                                            <th>Inserção</th>
                                            <th>Busca</th>
                                            <th>Vantagens</th>
                                            <th>Desvantagens</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Vetor</td>
                                            <td>Sequencial</td>
                                            <td>O(1)</td>
                                            <td>O(n)</td>
                                            <td>O(n)</td>
                                            <td>Acesso rápido</td>
                                            <td>Tamanho fixo</td>
                                        </tr>
                                        <tr>
                                            <td>Lista</td>
                                            <td>Ponteiros</td>
                                            <td>O(n)</td>
                                            <td>O(1)</td>
                                            <td>O(n)</td>
                                            <td>Tamanho dinâmico</td>
                                            <td>Sem acesso direto</td>
                                        </tr>
                                        <tr>
                                            <td>Pilha</td>
                                            <td>LIFO</td>
                                            <td>O(1)</td>
                                            <td>O(1)</td>
                                            <td>O(1)</td>
                                            <td>Simples</td>
                                            <td>Acesso limitado</td>
                                        </tr>
                                        <tr>
                                            <td>Fila</td>
                                            <td>FIFO</td>
                                            <td>O(1)</td>
                                            <td>O(1)</td>
                                            <td>O(1)</td>
                                            <td>Ordem garantida</td>
                                            <td>Acesso limitado</td>
                                        </tr>
                                        <tr>
                                            <td>Árvore Binária</td>
                                            <td>Hierárquico</td>
                                            <td>O(log n)</td>
                                            <td>O(log n)</td>
                                            <td>O(log n)</td>
                                            <td>Busca eficiente</td>
                                            <td>Pode desbalancear</td>
                                        </tr>
                                        <tr>
                                            <td>Grafo</td>
                                            <td>Relacionamentos</td>
                                            <td>O(V+E)</td>
                                            <td>O(1)</td>
                                            <td>O(V+E)</td>
                                            <td>Flexível</td>
                                            <td>Complexo</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Exercícios Section -->
        <section id="exercicios" class="section">
            <div class="container">
                <div class="section-header">
                    <h2 class="section-title">Exercícios Práticos</h2>
                    <p class="section-subtitle">Pratique implementações e conceitos</p>
                </div>
                
                <div class="exercises-grid">
                    <div class="exercise-card" data-aos="fade-up">
                        <div class="exercise-header">
                            <h3>Lista Encadeada</h3>
                            <span class="difficulty easy">Fácil</span>
                        </div>
                        <p>Implemente uma lista encadeada simples com inserção e remoção.</p>
                        <button class="btn btn-outline" onclick="showExercise('lista')">
                            Ver Exercício
                        </button>
                    </div>
                    
                    <div class="exercise-card" data-aos="fade-up" data-aos-delay="100">
                        <div class="exercise-header">
                            <h3>Pilha</h3>
                            <span class="difficulty medium">Médio</span>
                        </div>
                        <p>Crie uma pilha com operações push, pop e peek.</p>
                        <button class="btn btn-outline" onclick="showExercise('pilha')">
                            Ver Exercício
                        </button>
                    </div>
                    
                    <div class="exercise-card" data-aos="fade-up" data-aos-delay="200">
                        <div class="exercise-header">
                            <h3>Fila Circular</h3>
                            <span class="difficulty hard">Difícil</span>
                        </div>
                        <p>Implemente uma fila circular usando vetor.</p>
                        <button class="btn btn-outline" onclick="showExercise('fila')">
                            Ver Exercício
                        </button>
                    </div>

                    <div class="exercise-card" data-aos="fade-up" data-aos-delay="300">
                        <div class="exercise-header">
                            <h3>Árvore Binária</h3>
                            <span class="difficulty hard">Difícil</span>
                        </div>
                        <p>Implemente uma árvore binária de busca.</p>
                        <button class="btn btn-outline" onclick="showExercise('arvore')">
                            Ver Exercício
                        </button>
                    </div>

                    <div class="exercise-card" data-aos="fade-up" data-aos-delay="400">
                        <div class="exercise-header">
                            <h3>Grafo</h3>
                            <span class="difficulty mega">Mega Difícil</span>
                        </div>
                        <p>Implemente um grafo com matriz de adjacência.</p>
                        <button class="btn btn-outline" onclick="showExercise('grafo')">
                            Ver Exercício
                        </button>
                    </div>

                    <div class="exercise-card" data-aos="fade-up" data-aos-delay="500">
                        <div class="exercise-header">
                            <h3>Algoritmos de Ordenação</h3>
                            <span class="difficulty medium">Médio</span>
                        </div>
                        <p>Implemente bubble sort, quick sort e merge sort.</p>
                        <button class="btn btn-outline" onclick="showExercise('ordenacao')">
                            Ver Exercício
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Prova Section -->
        <section id="prova" class="section">
            <div class="container">
                <div class="section-header">
                    <h2 class="section-title">Prova de Múltipla Escolha</h2>
                    <p class="section-subtitle">Teste seus conhecimentos com 200 questões aleatorizadas</p>
                </div>

                <div class="quiz-container">
                    <div class="quiz-setup" id="quiz-setup">
                        <h3>🎯 Configuração da Prova</h3>
                        <p class="setup-description">Personalize sua prova de acordo com suas necessidades de estudo</p>
                        
                        <div class="quiz-options">
                            <div class="option-group">
                                <label>📊 Número de Questões:</label>
                                <select id="question-count">
                                    <option value="5">5 questões (Teste rápido)</option>
                                    <option value="10" selected>10 questões (Padrão)</option>
                                    <option value="15">15 questões</option>
                                    <option value="20">20 questões</option>
                                    <option value="25">25 questões</option>
                                    <option value="30">30 questões</option>
                                    <option value="40">40 questões</option>
                                    <option value="50">50 questões (Prova completa)</option>
                                </select>
                            </div>
                            <div class="option-group">
                                <label>🎚️ Nível de Dificuldade:</label>
                                <select id="difficulty">
                                    <option value="all" selected>Todas as dificuldades</option>
                                    <option value="easy">Fácil (Fundamentos)</option>
                                    <option value="medium">Médio (Conceitos)</option>
                                    <option value="hard">Difícil (Aplicação)</option>
                                    <option value="mega">Mega Difícil (Avançado)</option>
                                </select>
                            </div>
                            <div class="option-group">
                                <label>📚 Tópico Específico:</label>
                                <select id="topic">
                                    <option value="all" selected>Todos os tópicos</option>
                                    <option value="conceitos">Conceitos Fundamentais</option>
                                    <option value="listas">Listas Encadeadas</option>
                                    <option value="pilhas">Pilhas (LIFO)</option>
                                    <option value="filas">Filas (FIFO)</option>
                                    <option value="arvores">Árvores</option>
                                    <option value="grafos">Grafos</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="setup-info">
                            <div class="info-card">
                                <i class="fas fa-info-circle"></i>
                                <div>
                                    <h4>Como funciona?</h4>
                                    <p>O sistema seleciona questões aleatoriamente baseado nos filtros escolhidos. Quanto mais específicos os filtros, menos questões disponíveis.</p>
                                </div>
                            </div>
                        </div>
                        
                        <button class="btn btn-primary btn-large" onclick="startQuiz()">
                            <i class="fas fa-play"></i>
                            🚀 Iniciar Prova
                        </button>
                    </div>

                    <div class="quiz-interface" id="quiz-interface" style="display: none;">
                        <div class="quiz-header">
                            <div class="quiz-info">
                                <span id="question-counter">Questão 1 de 10</span>
                                <span id="quiz-timer">Tempo: 00:00</span>
                            </div>
                            <div class="quiz-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progress-fill"></div>
                                </div>
                            </div>
                        </div>

                        <div class="question-container">
                            <h3 id="question-text">Carregando questão...</h3>
                            <div class="options-container" id="options-container">
                                <!-- Opções serão carregadas aqui -->
                            </div>
                        </div>

                        <div class="quiz-controls">
                            <button class="btn btn-secondary" onclick="previousQuestion()" id="prev-btn">
                                <i class="fas fa-arrow-left"></i>
                                Anterior
                            </button>
                            <button class="btn btn-primary" onclick="nextQuestion()" id="next-btn">
                                Próxima
                                <i class="fas fa-arrow-right"></i>
                            </button>
                            <button class="btn btn-success" onclick="finishQuiz()" id="finish-btn" style="display: none;">
                                <i class="fas fa-check"></i>
                                Finalizar
                            </button>
                        </div>
                    </div>

                    <div class="quiz-results" id="quiz-results" style="display: none;">
                        <h3>Resultado da Prova</h3>
                        <div class="results-summary">
                            <div class="result-item">
                                <i class="fas fa-trophy"></i>
                                <span>Nota: <strong id="final-score">0</strong>/10</span>
                            </div>
                            <div class="result-item">
                                <i class="fas fa-check-circle"></i>
                                <span>Acertos: <strong id="correct-answers">0</strong></span>
                            </div>
                            <div class="result-item">
                                <i class="fas fa-times-circle"></i>
                                <span>Erros: <strong id="wrong-answers">0</strong></span>
                            </div>
                            <div class="result-item">
                                <i class="fas fa-clock"></i>
                                <span>Tempo: <strong id="total-time">00:00</strong></span>
                            </div>
                        </div>
                        <div class="performance-chart">
                            <canvas id="performance-chart"></canvas>
                        </div>
                        <div class="quiz-actions">
                            <button class="btn btn-primary" onclick="reviewQuiz()">
                                <i class="fas fa-eye"></i>
                                Revisar Respostas
                            </button>
                            <button class="btn btn-secondary" onclick="newQuiz()">
                                <i class="fas fa-redo"></i>
                                Nova Prova
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Resumo Section -->
        <section id="resumo" class="section">
            <div class="container">
                <div class="section-header">
                    <h2 class="section-title">Resumo Executivo</h2>
                    <p class="section-subtitle">Informações essenciais para a prova</p>
                </div>
                
                <div class="summary-grid">
                    <div class="summary-card">
                        <h3>Questões Mais Comuns</h3>
                        <ul>
                            <li>Lista encadeada → valor + ponteiro</li>
                            <li>Vantagem listas vs vetores → inserção/remoção eficiente</li>
                            <li>FIFO → First In, First Out</li>
                            <li>LIFO → Last In, First Out</li>
                            <li>malloc() → aloca memória dinamicamente</li>
                            <li>free() → libera memória alocada</li>
                            <li>NULL → indica ponteiro nulo</li>
                            <li>Índice último elemento vetor → tamanho-1</li>
                            <li>Pilha vazia → top = -1</li>
                            <li>Fila circular → uso do operador módulo (%)</li>
                        </ul>
                    </div>
                    
                    <div class="summary-card">
                        <h3>Dicas para a Prova</h3>
                        <ul>
                            <li>Memorize LIFO (pilhas) e FIFO (filas)</li>
                            <li>Entenda diferenças entre estruturas estáticas e dinâmicas</li>
                            <li>Pratique implementações básicas em C</li>
                            <li>Atenção aos ponteiros e NULL</li>
                            <li>Revise vantagens/desvantagens de cada estrutura</li>
                            <li>Teste casos extremos (vazio, um elemento, cheio)</li>
                            <li>Sempre libere memória com free()</li>
                            <li>Use módulo (%) em filas circulares</li>
                            <li>Entenda complexidade de tempo das operações</li>
                            <li>Pratique algoritmos de ordenação</li>
                        </ul>
                    </div>

                    <div class="summary-card">
                        <h3>Complexidade de Tempo</h3>
                        <ul>
                            <li><strong>Vetor:</strong> Acesso O(1), Inserção O(n)</li>
                            <li><strong>Lista:</strong> Acesso O(n), Inserção O(1)</li>
                            <li><strong>Pilha:</strong> Push/Pop O(1)</li>
                            <li><strong>Fila:</strong> Enqueue/Dequeue O(1)</li>
                            <li><strong>Árvore Binária:</strong> Busca O(log n)</li>
                            <li><strong>Grafo:</strong> Busca O(V+E)</li>
                        </ul>
                    </div>

                    <div class="summary-card">
                        <h3>Pontos Críticos</h3>
                        <ul>
                            <li><strong>Vazamento de memória:</strong> Sempre use free()</li>
                            <li><strong>Ponteiros nulos:</strong> Sempre verifique NULL</li>
                            <li><strong>Índices:</strong> Começam em 0, último = tamanho-1</li>
                            <li><strong>Fila circular:</strong> Use (rear + 1) % MAX</li>
                            <li><strong>Pilha:</strong> Verifique se está vazia antes de pop</li>
                            <li><strong>Lista:</strong> Atualize ponteiros corretamente</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <i class="fas fa-brain"></i>
                    <span>Estrutura de Dados</span>
                </div>
                <p>Material de estudo completo para o 2º bimestre</p>
                <div class="footer-stats">
                    <span>200 Questões</span>
                    <span>•</span>
                    <span>6 Estruturas</span>
                    <span>•</span>
                    <span>4 Níveis</span>
                </div>
            </div>
        </div>
    </footer>

    <!-- Modal for Exercises -->
    <div id="exercise-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title">Exercício</h3>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- Content will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Exercise Modals -->
    <div id="lista-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>📋 Exercício: Lista Encadeada</h3>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="exercise-content">
                    <h4>🎯 Objetivo</h4>
                    <p>Implemente uma lista encadeada simples com inserção e remoção de elementos.</p>
                    
                    <h4>📝 Enunciado</h4>
                    <p>Complete o código abaixo para implementar uma lista encadeada simples:</p>
                    
                    <div class="code-block">
                        <h5>Estrutura e Funções:</h5>
                        <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Função para criar um novo nó
Node* createNode(int value) {
    // COMPLETE AQUI
}

// Função para inserir no início
void insertAtBeginning(Node** head, int value) {
    // COMPLETE AQUI
}

// Função para inserir no final
void insertAtEnd(Node** head, int value) {
    // COMPLETE AQUI
}

// Função para remover um elemento
void deleteNode(Node** head, int value) {
    // COMPLETE AQUI
}

// Função para imprimir a lista
void printList(Node* head) {
    // COMPLETE AQUI
}</code></pre>
                    </div>
                    
                    <div class="solution-toggle">
                        <button class="btn btn-outline" onclick="toggleSolution('lista-solution')">
                            👁️ Ver Solução
                        </button>
                    </div>
                    
                    <div id="lista-solution" class="solution" style="display: none;">
                        <h4>✅ Solução Completa:</h4>
                        <pre><code>Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

void insertAtBeginning(Node** head, int value) {
    Node* newNode = createNode(value);
    newNode->next = *head;
    *head = newNode;
}

void insertAtEnd(Node** head, int value) {
    Node* newNode = createNode(value);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
}

void deleteNode(Node** head, int value) {
    if (*head == NULL) return;
    
    if ((*head)->data == value) {
        Node* temp = *head;
        *head = (*head)->next;
        free(temp);
        return;
    }
    
    Node* current = *head;
    while (current->next != NULL && current->next->data != value) {
        current = current->next;
    }
    
    if (current->next != NULL) {
        Node* temp = current->next;
        current->next = temp->next;
        free(temp);
    }
}

void printList(Node* head) {
    Node* current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}</code></pre>
                        
                        <h4>🔍 Pontos Importantes:</h4>
                        <ul>
                            <li><strong>Alocação de memória:</strong> Sempre use malloc() para criar novos nós</li>
                            <li><strong>Liberação de memória:</strong> Use free() ao remover nós</li>
                            <li><strong>Ponteiros:</strong> Atualize corretamente os ponteiros next</li>
                            <li><strong>Verificações:</strong> Sempre verifique se a lista está vazia</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="pilha-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>📚 Exercício: Pilha</h3>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="exercise-content">
                    <h4>🎯 Objetivo</h4>
                    <p>Implemente uma pilha usando vetor com as operações push, pop e peek.</p>
                    
                    <h4>📝 Enunciado</h4>
                    <p>Complete o código abaixo para implementar uma pilha:</p>
                    
                    <div class="code-block">
                        <h5>Estrutura e Funções:</h5>
                        <pre><code>#define MAX 100

typedef struct {
    int data[MAX];
    int top;
} Stack;

// Inicializar pilha
void initStack(Stack* s) {
    // COMPLETE AQUI
}

// Verificar se está vazia
int isEmpty(Stack* s) {
    // COMPLETE AQUI
}

// Verificar se está cheia
int isFull(Stack* s) {
    // COMPLETE AQUI
}

// Empilhar elemento
void push(Stack* s, int value) {
    // COMPLETE AQUI
}

// Desempilhar elemento
int pop(Stack* s) {
    // COMPLETE AQUI
}

// Ver elemento do topo
int peek(Stack* s) {
    // COMPLETE AQUI
}</code></pre>
                    </div>
                    
                    <div class="solution-toggle">
                        <button class="btn btn-outline" onclick="toggleSolution('pilha-solution')">
                            👁️ Ver Solução
                        </button>
                    </div>
                    
                    <div id="pilha-solution" class="solution" style="display: none;">
                        <h4>✅ Solução Completa:</h4>
                        <pre><code>void initStack(Stack* s) {
    s->top = -1;
}

int isEmpty(Stack* s) {
    return s->top == -1;
}

int isFull(Stack* s) {
    return s->top == MAX - 1;
}

void push(Stack* s, int value) {
    if (isFull(s)) {
        printf("Pilha cheia!\n");
        return;
    }
    s->data[++s->top] = value;
}

int pop(Stack* s) {
    if (isEmpty(s)) {
        printf("Pilha vazia!\n");
        return -1;
    }
    return s->data[s->top--];
}

int peek(Stack* s) {
    if (isEmpty(s)) {
        printf("Pilha vazia!\n");
        return -1;
    }
    return s->data[s->top];
}</code></pre>
                        
                        <h4>🔍 Pontos Importantes:</h4>
                        <ul>
                            <li><strong>Top inicial:</strong> Começa em -1 (pilha vazia)</li>
                            <li><strong>Push:</strong> Incrementa top antes de inserir</li>
                            <li><strong>Pop:</strong> Retorna valor e decrementa top</li>
                            <li><strong>Verificações:</strong> Sempre verifique se está vazia/cheia</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="fila-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🔄 Exercício: Fila Circular</h3>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="exercise-content">
                    <h4>🎯 Objetivo</h4>
                    <p>Implemente uma fila circular usando vetor com as operações enqueue, dequeue e peek.</p>
                    
                    <h4>📝 Enunciado</h4>
                    <p>Complete o código abaixo para implementar uma fila circular:</p>
                    
                    <div class="code-block">
                        <h5>Estrutura e Funções:</h5>
                        <pre><code>#define MAX 100

typedef struct {
    int data[MAX];
    int front;
    int rear;
    int size;
} CircularQueue;

// Inicializar fila
void initQueue(CircularQueue* q) {
    // COMPLETE AQUI
}

// Verificar se está vazia
int isEmpty(CircularQueue* q) {
    // COMPLETE AQUI
}

// Verificar se está cheia
int isFull(CircularQueue* q) {
    // COMPLETE AQUI
}

// Inserir elemento
void enqueue(CircularQueue* q, int value) {
    // COMPLETE AQUI
}

// Remover elemento
int dequeue(CircularQueue* q) {
    // COMPLETE AQUI
}

// Ver primeiro elemento
int peek(CircularQueue* q) {
    // COMPLETE AQUI
}</code></pre>
                    </div>
                    
                    <div class="solution-toggle">
                        <button class="btn btn-outline" onclick="toggleSolution('fila-solution')">
                            👁️ Ver Solução
                        </button>
                    </div>
                    
                    <div id="fila-solution" class="solution" style="display: none;">
                        <h4>✅ Solução Completa:</h4>
                        <pre><code>void initQueue(CircularQueue* q) {
    q->front = 0;
    q->rear = -1;
    q->size = 0;
}

int isEmpty(CircularQueue* q) {
    return q->size == 0;
}

int isFull(CircularQueue* q) {
    return q->size == MAX;
}

void enqueue(CircularQueue* q, int value) {
    if (isFull(q)) {
        printf("Fila cheia!\n");
        return;
    }
    q->rear = (q->rear + 1) % MAX;
    q->data[q->rear] = value;
    q->size++;
}

int dequeue(CircularQueue* q) {
    if (isEmpty(q)) {
        printf("Fila vazia!\n");
        return -1;
    }
    int value = q->data[q->front];
    q->front = (q->front + 1) % MAX;
    q->size--;
    return value;
}

int peek(CircularQueue* q) {
    if (isEmpty(q)) {
        printf("Fila vazia!\n");
        return -1;
    }
    return q->data[q->front];
}</code></pre>
                        
                        <h4>🔍 Pontos Importantes:</h4>
                        <ul>
                            <li><strong>Operador módulo:</strong> Use % MAX para voltar ao início</li>
                            <li><strong>Controle de tamanho:</strong> Use size para verificar vazio/cheio</li>
                            <li><strong>Front e Rear:</strong> Atualize corretamente os índices</li>
                            <li><strong>Circularidade:</strong> (rear + 1) % MAX e (front + 1) % MAX</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="arvore-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🌳 Exercício: Árvore Binária</h3>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="exercise-content">
                    <h4>🎯 Objetivo</h4>
                    <p>Implemente uma árvore binária de busca com inserção, busca e percorrimentos.</p>
                    
                    <h4>📝 Enunciado</h4>
                    <p>Complete o código abaixo para implementar uma árvore binária:</p>
                    
                    <div class="code-block">
                        <h5>Estrutura e Funções:</h5>
                        <pre><code>typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} Node;

// Criar novo nó
Node* createNode(int value) {
    // COMPLETE AQUI
}

// Inserir elemento
Node* insert(Node* root, int value) {
    // COMPLETE AQUI
}

// Buscar elemento
Node* search(Node* root, int value) {
    // COMPLETE AQUI
}

// Percorrimento em ordem (inorder)
void inorder(Node* root) {
    // COMPLETE AQUI
}

// Percorrimento pré-ordem (preorder)
void preorder(Node* root) {
    // COMPLETE AQUI
}

// Percorrimento pós-ordem (postorder)
void postorder(Node* root) {
    // COMPLETE AQUI
}</code></pre>
                    </div>
                    
                    <div class="solution-toggle">
                        <button class="btn btn-outline" onclick="toggleSolution('arvore-solution')">
                            👁️ Ver Solução
                        </button>
                    </div>
                    
                    <div id="arvore-solution" class="solution" style="display: none;">
                        <h4>✅ Solução Completa:</h4>
                        <pre><code>Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

Node* insert(Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    
    if (value < root->data) {
        root->left = insert(root->left, value);
    } else if (value > root->data) {
        root->right = insert(root->right, value);
    }
    
    return root;
}

Node* search(Node* root, int value) {
    if (root == NULL || root->data == value) {
        return root;
    }
    
    if (value < root->data) {
        return search(root->left, value);
    }
    
    return search(root->right, value);
}

void inorder(Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

void preorder(Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

void postorder(Node* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}</code></pre>
                        
                        <h4>🔍 Pontos Importantes:</h4>
                        <ul>
                            <li><strong>Recursão:</strong> Use recursão para navegar na árvore</li>
                            <li><strong>Comparação:</strong> Menor vai para esquerda, maior para direita</li>
                            <li><strong>Percorrimentos:</strong> Inorder = ordenado, Preorder = raiz primeiro</li>
                            <li><strong>Alocação:</strong> Sempre aloque memória para novos nós</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="grafo-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🕸️ Exercício: Grafo</h3>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="exercise-content">
                    <h4>🎯 Objetivo</h4>
                    <p>Implemente um grafo usando matriz de adjacência com busca em largura (BFS) e profundidade (DFS).</p>
                    
                    <h4>📝 Enunciado</h4>
                    <p>Complete o código abaixo para implementar um grafo:</p>
                    
                    <div class="code-block">
                        <h5>Estrutura e Funções:</h5>
                        <pre><code>#define MAX_VERTICES 100

typedef struct {
    int vertices;
    int adjMatrix[MAX_VERTICES][MAX_VERTICES];
} Graph;

// Inicializar grafo
void initGraph(Graph* g, int vertices) {
    // COMPLETE AQUI
}

// Adicionar aresta
void addEdge(Graph* g, int src, int dest) {
    // COMPLETE AQUI
}

// Busca em Largura (BFS)
void BFS(Graph* g, int startVertex) {
    // COMPLETE AQUI
}

// Busca em Profundidade (DFS)
void DFS(Graph* g, int startVertex) {
    // COMPLETE AQUI
}</code></pre>
                    </div>
                    
                    <div class="solution-toggle">
                        <button class="btn btn-outline" onclick="toggleSolution('grafo-solution')">
                            👁️ Ver Solução
                        </button>
                    </div>
                    
                    <div id="grafo-solution" class="solution" style="display: none;">
                        <h4>✅ Solução Completa:</h4>
                        <pre><code>void initGraph(Graph* g, int vertices) {
    g->vertices = vertices;
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            g->adjMatrix[i][j] = 0;
        }
    }
}

void addEdge(Graph* g, int src, int dest) {
    g->adjMatrix[src][dest] = 1;
    g->adjMatrix[dest][src] = 1; // Para grafo não dirigido
}

void BFS(Graph* g, int startVertex) {
    bool visited[MAX_VERTICES] = {false};
    int queue[MAX_VERTICES];
    int front = 0, rear = 0;
    
    visited[startVertex] = true;
    queue[rear++] = startVertex;
    
    printf("BFS: ");
    while (front < rear) {
        int vertex = queue[front++];
        printf("%d ", vertex);
        
        for (int i = 0; i < g->vertices; i++) {
            if (g->adjMatrix[vertex][i] && !visited[i]) {
                visited[i] = true;
                queue[rear++] = i;
            }
        }
    }
    printf("\n");
}

void DFS(Graph* g, int startVertex) {
    bool visited[MAX_VERTICES] = {false};
    printf("DFS: ");
    DFSUtil(g, startVertex, visited);
    printf("\n");
}

void DFSUtil(Graph* g, int vertex, bool visited[]) {
    visited[vertex] = true;
    printf("%d ", vertex);
    
    for (int i = 0; i < g->vertices; i++) {
        if (g->adjMatrix[vertex][i] && !visited[i]) {
            DFSUtil(g, i, visited);
        }
    }
}</code></pre>
                        
                        <h4>🔍 Pontos Importantes:</h4>
                        <ul>
                            <li><strong>Matriz de adjacência:</strong> 1 = aresta existe, 0 = não existe</li>
                            <li><strong>BFS:</strong> Usa fila, visita vizinhos primeiro</li>
                            <li><strong>DFS:</strong> Usa recursão, vai até o final</li>
                            <li><strong>Visited array:</strong> Evita visitar o mesmo vértice</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="ordenacao-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>📊 Exercício: Algoritmos de Ordenação</h3>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="exercise-content">
                    <h4>🎯 Objetivo</h4>
                    <p>Implemente os algoritmos de ordenação Bubble Sort, Selection Sort e Quick Sort.</p>
                    
                    <h4>📝 Enunciado</h4>
                    <p>Complete o código abaixo para implementar os algoritmos de ordenação:</p>
                    
                    <div class="code-block">
                        <h5>Funções:</h5>
                        <pre><code>// Bubble Sort
void bubbleSort(int arr[], int n) {
    // COMPLETE AQUI
}

// Selection Sort
void selectionSort(int arr[], int n) {
    // COMPLETE AQUI
}

// Quick Sort - Função de partição
int partition(int arr[], int low, int high) {
    // COMPLETE AQUI
}

// Quick Sort
void quickSort(int arr[], int low, int high) {
    // COMPLETE AQUI
}</code></pre>
                    </div>
                    
                    <div class="solution-toggle">
                        <button class="btn btn-outline" onclick="toggleSolution('ordenacao-solution')">
                            👁️ Ver Solução
                        </button>
                    </div>
                    
                    <div id="ordenacao-solution" class="solution" style="display: none;">
                        <h4>✅ Solução Completa:</h4>
                        <pre><code>void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                swap(&arr[j], &arr[j+1]);
            }
        }
    }
}

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        int min_idx = i;
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(&arr[min_idx], &arr[i]);
    }
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}</code></pre>
                        
                        <h4>🔍 Pontos Importantes:</h4>
                        <ul>
                            <li><strong>Bubble Sort:</strong> O(n²), compara elementos adjacentes</li>
                            <li><strong>Selection Sort:</strong> O(n²), encontra mínimo e troca</li>
                            <li><strong>Quick Sort:</strong> O(n log n), usa pivô e partição</li>
                            <li><strong>Complexidade:</strong> Bubble/Selection = O(n²), Quick = O(n log n)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="js/main.js"></script>
    <script src="js/animations.js"></script>
    <script src="js/quiz.js"></script>
</body>
</html> 