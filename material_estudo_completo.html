<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Material de Estudo - Estrutura de Dados</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #e74c3c;
            font-size: 1.8em;
            margin: 30px 0 15px 0;
            border-left: 4px solid #e74c3c;
            padding-left: 15px;
        }
        
        h3 {
            color: #2980b9;
            font-size: 1.4em;
            margin: 25px 0 10px 0;
        }
        
        h4 {
            color: #27ae60;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            font-size: 1.2em;
            margin-bottom: 30px;
        }
        
        .toc {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .toc h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .toc ul {
            list-style: none;
        }
        
        .toc li {
            margin: 8px 0;
        }
        
        .toc a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        
        .toc a:hover {
            color: #e74c3c;
            text-decoration: underline;
        }
        
        .question {
            background: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .answer {
            background: #e8f5e8;
            padding: 15px;
            border-left: 4px solid #27ae60;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .code {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 10px 0;
        }
        
        .tip {
            background: #d1ecf1;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #17a2b8;
            margin: 15px 0;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        .comparison-table th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .comparison-table tr:hover {
            background-color: #e8f4f8;
        }
        
        .section {
            margin: 40px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        
        .exercise {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 2px solid #dee2e6;
        }
        
        .exercise h4 {
            color: #495057;
            margin-bottom: 15px;
        }
        
        .solution {
            background: #d4edda;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            border-left: 4px solid #28a745;
        }
        
        .important {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #dc3545;
            margin: 15px 0;
        }
        
        .success {
            background: #d1e7dd;
            color: #0f5132;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #198754;
            margin: 15px 0;
        }
        
        ul, ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        li {
            margin: 5px 0;
        }
        
        .nav-buttons {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .nav-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .nav-btn:hover {
            background: #2980b9;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .nav-buttons {
                position: static;
                margin: 20px 0;
                flex-direction: row;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="nav-buttons">
        <button class="nav-btn" onclick="scrollToSection('conceitos')">Conceitos</button>
        <button class="nav-btn" onclick="scrollToSection('listas')">Listas</button>
        <button class="nav-btn" onclick="scrollToSection('pilhas')">Pilhas</button>
        <button class="nav-btn" onclick="scrollToSection('filas')">Filas</button>
        <button class="nav-btn" onclick="scrollToSection('exercicios')">Exerc√≠cios</button>
        <button class="nav-btn" onclick="scrollToSection('resumo')">Resumo</button>
    </div>

    <div class="container">
        <h1>üìö MATERIAL DE ESTUDO - ESTRUTURA DE DADOS</h1>
        <p class="subtitle">2¬∫ Bimestre - Prepara√ß√£o Completa para Prova</p>

        <div class="toc">
            <h3>üìã √çNDICE</h3>
            <ul>
                <li><a href="#conceitos">1. Conceitos Fundamentais</a></li>
                <li><a href="#listas">2. Listas Encadeadas</a></li>
                <li><a href="#pilhas">3. Pilhas</a></li>
                <li><a href="#filas">4. Filas</a></li>
                <li><a href="#vetores">5. Vetores e Matrizes</a></li>
                <li><a href="#exercicios">6. Exerc√≠cios Pr√°ticos</a></li>
                <li><a href="#questoes">7. Quest√µes de M√∫ltipla Escolha</a></li>
                <li><a href="#resumo">8. Resumo Executivo</a></li>
            </ul>
        </div>

        <!-- 1. CONCEITOS FUNDAMENTAIS -->
        <div id="conceitos" class="section">
            <h2>1. CONCEITOS FUNDAMENTAIS</h2>
            
            <div class="question">
                <h4>O que s√£o dados em Tecnologia da Informa√ß√£o?</h4>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> Dados s√£o elementos brutos e isolados que representam aspectos da realidade. S√£o a mat√©ria-prima que, quando processada, se transforma em informa√ß√£o √∫til.
            </div>

            <h3>Estruturas Homog√™neas vs Heterog√™neas</h3>
            <div class="highlight">
                <strong>Homog√™neas:</strong> Armazenam apenas um tipo de dado (ex: vetor de inteiros)<br>
                <strong>Heterog√™neas:</strong> Armazenam diferentes tipos de dados (ex: struct)
            </div>

            <h3>Vetores (Arrays)</h3>
            <ul>
                <li>Estrutura de dados linear</li>
                <li>Elementos armazenados em posi√ß√µes cont√≠nuas da mem√≥ria</li>
                <li>Acesso direto por √≠ndice</li>
                <li>Tamanho fixo (desvantagem)</li>
                <li>Alto custo para inser√ß√£o/remo√ß√£o no meio</li>
            </ul>

            <h3>Matrizes</h3>
            <ul>
                <li>Estrutura de dados bidimensional</li>
                <li>Organizada em linhas e colunas</li>
                <li>√ötil para representar tabelas, imagens, etc.</li>
            </ul>
        </div>

        <!-- 2. LISTAS ENCADEADAS -->
        <div id="listas" class="section">
            <h2>2. LISTAS ENCADEADAS</h2>
            
            <h3>Caracter√≠sticas das Listas Encadeadas</h3>
            <ul>
                <li>Cada n√≥ cont√©m um valor e um ponteiro para o pr√≥ximo</li>
                <li>Elementos N√ÉO s√£o armazenados em posi√ß√µes cont√≠nuas</li>
                <li>Tamanho din√¢mico</li>
                <li>Inser√ß√£o e remo√ß√£o eficientes em qualquer posi√ß√£o</li>
            </ul>

            <h3>Vantagens vs Vetores</h3>
            <div class="highlight">
                <strong>Vantagens:</strong> Tamanho din√¢mico, inser√ß√£o/remo√ß√£o eficiente<br>
                <strong>Desvantagens:</strong> Sem acesso direto, uso de ponteiros
            </div>

            <div class="question">
                <h4>O que acontece com o ponteiro quando a lista est√° vazia?</h4>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> O ponteiro recebe NULL quando a lista est√° vazia.
            </div>

            <h3>Fun√ß√µes importantes em C</h3>
            <ul>
                <li><strong>malloc():</strong> Aloca mem√≥ria dinamicamente</li>
                <li><strong>free():</strong> Libera a mem√≥ria alocada</li>
            </ul>

            <h3>Estrutura b√°sica de um n√≥</h3>
            <div class="code">
typedef struct Node {
    int data;
    struct Node* next;
} Node;
            </div>

            <h3>Implementa√ß√£o Completa de Lista Encadeada</h3>
            <div class="code">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

void insertAtEnd(Node** head, int value) {
    Node* newNode = createNode(value);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
}

void printList(Node* head) {
    Node* current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\\n");
}
            </div>
        </div>

        <!-- 3. PILHAS -->
        <div id="pilhas" class="section">
            <h2>3. PILHAS</h2>
            
            <h3>Caracter√≠sticas das Pilhas</h3>
            <ul>
                <li>Estrutura de dados linear</li>
                <li>LIFO: Last In, First Out (√∫ltimo a entrar, primeiro a sair)</li>
                <li>Opera√ß√µes: PUSH (empilhar) e POP (desempilhar)</li>
                <li>Acesso apenas ao topo da pilha</li>
            </ul>

            <h3>Exemplos de uso</h3>
            <ul>
                <li>Chamadas de fun√ß√£o (call stack)</li>
                <li>Desfazer opera√ß√µes (undo)</li>
                <li>Avalia√ß√£o de express√µes</li>
                <li>Navega√ß√£o em navegadores (bot√£o voltar)</li>
            </ul>

            <h3>Implementa√ß√£o b√°sica</h3>
            <div class="code">
#define MAX 100
typedef struct {
    int data[MAX];
    int top;
} Stack;

void push(Stack* s, int value) {
    if (s->top < MAX-1) {
        s->data[++s->top] = value;
    }
}

int pop(Stack* s) {
    if (s->top >= 0) {
        return s->data[s->top--];
    }
    return -1; // erro
}

int isEmpty(Stack* s) {
    return s->top == -1;
}

int isFull(Stack* s) {
    return s->top == MAX - 1;
}
            </div>
        </div>

        <!-- 4. FILAS -->
        <div id="filas" class="section">
            <h2>4. FILAS</h2>
            
            <h3>Caracter√≠sticas das Filas</h3>
            <ul>
                <li>Estrutura de dados linear</li>
                <li>FIFO: First In, First Out (primeiro a entrar, primeiro a sair)</li>
                <li>Inser√ß√£o no final, remo√ß√£o no in√≠cio</li>
                <li>Controle de ordem de execu√ß√£o</li>
            </ul>

            <h3>Exemplos reais</h3>
            <ul>
                <li>Fila de pessoas</li>
                <li>Fila de impress√£o</li>
                <li>Senhas em atendimento</li>
                <li>Buffers de rede</li>
                <li>Filas de processos</li>
            </ul>

            <h3>Implementa√ß√£o com vetor (Fila Circular)</h3>
            <div class="code">
#define MAX 10
typedef struct {
    int data[MAX];
    int front, rear;
    int size;
} Queue;

void initQueue(Queue* q) {
    q->front = 0;
    q->rear = -1;
    q->size = 0;
}

void enqueue(Queue* q, int value) {
    if (!isFull(q)) {
        q->rear = (q->rear + 1) % MAX;
        q->data[q->rear] = value;
        q->size++;
    }
}

int dequeue(Queue* q) {
    if (!isEmpty(q)) {
        int value = q->data[q->front];
        q->front = (q->front + 1) % MAX;
        q->size--;
        return value;
    }
    return -1; // fila vazia
}

int isEmpty(Queue* q) {
    return q->size == 0;
}

int isFull(Queue* q) {
    return q->size == MAX;
}
            </div>
        </div>

        <!-- 5. VETORES E MATRIZES -->
        <div id="vetores" class="section">
            <h2>5. VETORES E MATRIZES</h2>
            
            <h3>Diferen√ßas para estruturas din√¢micas</h3>
            <div class="highlight">
                <strong>Vetores/Matrizes:</strong> Tamanho fixo, acesso direto, mem√≥ria cont√≠nua<br>
                <strong>Pilhas/Listas/Filas:</strong> Tamanho din√¢mico, opera√ß√µes espec√≠ficas, flexibilidade
            </div>

            <div class="question">
                <h4>Em um vetor de 10 posi√ß√µes, qual √© o √≠ndice do √∫ltimo elemento?</h4>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> O √≠ndice do √∫ltimo elemento √© 9, pois os √≠ndices come√ßam em 0.
            </div>

            <h3>√çndices em vetores</h3>
            <ul>
                <li>Primeiro elemento: √≠ndice 0</li>
                <li>√öltimo elemento: √≠ndice (tamanho - 1)</li>
                <li>Exemplo: vetor de 10 posi√ß√µes, √∫ltimo elemento = √≠ndice 9</li>
            </ul>
        </div>

        <!-- 6. EXERC√çCIOS PR√ÅTICOS -->
        <div id="exercicios" class="section">
            <h2>6. EXERC√çCIOS PR√ÅTICOS</h2>
            
            <div class="exercise">
                <h4>EXERC√çCIO 1: Implementa√ß√£o de Lista Encadeada</h4>
                <p>Complete o c√≥digo abaixo para implementar uma lista encadeada simples:</p>
                <div class="code">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Fun√ß√£o para criar um novo n√≥
Node* createNode(int value) {
    // COMPLETE AQUI
}

// Fun√ß√£o para inserir no in√≠cio
void insertAtBeginning(Node** head, int value) {
    // COMPLETE AQUI
}

// Fun√ß√£o para inserir no final
void insertAtEnd(Node** head, int value) {
    // COMPLETE AQUI
}

// Fun√ß√£o para remover um elemento
void deleteNode(Node** head, int value) {
    // COMPLETE AQUI
}

// Fun√ß√£o para imprimir a lista
void printList(Node* head) {
    // COMPLETE AQUI
}
                </div>
                
                <div class="solution">
                    <h4>SOLU√á√ÉO:</h4>
                    <div class="code">
Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

void insertAtBeginning(Node** head, int value) {
    Node* newNode = createNode(value);
    newNode->next = *head;
    *head = newNode;
}

void insertAtEnd(Node** head, int value) {
    Node* newNode = createNode(value);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
}

void deleteNode(Node** head, int value) {
    // COMPLETE AQUI
}

void printList(Node* head) {
    // COMPLETE AQUI
}
                    </div>
                </div>
            </div>

            <div class="exercise">
                <h4>EXERC√çCIO 2: Implementa√ß√£o de Pilha</h4>
                <p>Implemente uma pilha usando vetor com as opera√ß√µes push, pop e peek:</p>
                <div class="code">
#define MAX 100

typedef struct {
    int data[MAX];
    int top;
} Stack;

// Inicializar pilha
void initStack(Stack* s) {
    // COMPLETE AQUI
}

// Verificar se est√° vazia
int isEmpty(Stack* s) {
    // COMPLETE AQUI
}

// Verificar se est√° cheia
int isFull(Stack* s) {
    // COMPLETE AQUI
}

// Empilhar elemento
void push(Stack* s, int value) {
    // COMPLETE AQUI
}

// Desempilhar elemento
int pop(Stack* s) {
    // COMPLETE AQUI
}

// Ver elemento do topo
int peek(Stack* s) {
    // COMPLETE AQUI
}
                </div>
                
                <div class="solution">
                    <h4>SOLU√á√ÉO:</h4>
                    <div class="code">
void initStack(Stack* s) {
    s->top = -1;
}

int isEmpty(Stack* s) {
    return s->top == -1;
}

int isFull(Stack* s) {
    return s->top == MAX - 1;
}

void push(Stack* s, int value) {
    if (!isFull(s)) {
        s->data[++s->top] = value;
    }
}

int pop(Stack* s) {
    if (!isEmpty(s)) {
        return s->data[s->top--];
    }
    return -1; // erro
}

int peek(Stack* s) {
    if (!isEmpty(s)) {
        return s->data[s->top];
    }
    return -1; // erro
}
                    </div>
                </div>
            </div>

            <div class="exercise">
                <h4>EXERC√çCIO 3: Quest√µes Conceituais</h4>
                
                <div class="question">
                    <h4>1. Explique a diferen√ßa entre LIFO e FIFO com exemplos pr√°ticos.</h4>
                </div>
                <div class="answer">
                    <strong>Resposta:</strong> LIFO (Last In, First Out): √öltimo a entrar, primeiro a sair. Exemplo: Pilha de pratos, call stack de fun√ß√µes. FIFO (First In, First Out): Primeiro a entrar, primeiro a sair. Exemplo: Fila de pessoas, fila de impress√£o.
                </div>

                <div class="question">
                    <h4>2. Qual a diferen√ßa entre aloca√ß√£o est√°tica e din√¢mica de mem√≥ria?</h4>
                </div>
                <div class="answer">
                    <strong>Resposta:</strong> Est√°tica: Tamanho definido em tempo de compila√ß√£o, mem√≥ria alocada na stack. Din√¢mica: Tamanho definido em tempo de execu√ß√£o, mem√≥ria alocada na heap usando malloc/free.
                </div>

                <div class="question">
                    <h4>3. Por que listas encadeadas s√£o mais eficientes para inser√ß√£o/remo√ß√£o no meio?</h4>
                </div>
                <div class="answer">
                    <strong>Resposta:</strong> Em vetores, inser√ß√£o/remo√ß√£o no meio requer deslocar todos os elementos seguintes. Em listas encadeadas, apenas os ponteiros s√£o alterados, sem necessidade de deslocamento.
                </div>
            </div>
        </div>

        <!-- 7. QUEST√ïES DE M√öLTIPLA ESCOLHA -->
        <div id="questoes" class="section">
            <h2>7. QUEST√ïES DE M√öLTIPLA ESCOLHA</h2>
            
            <div class="question">
                <h4>1. O que caracteriza uma lista encadeada simples em C?</h4>
                <p>a) Todos os elementos s√£o armazenados em posi√ß√µes cont√≠nuas da mem√≥ria</p>
                <p>b) Cada n√≥ aponta para o n√≥ anterior</p>
                <p>c) Cada n√≥ cont√©m um valor e um ponteiro para o pr√≥ximo</p>
                <p>d) √â uma estrutura baseada em arquivos</p>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> c) Cada n√≥ cont√©m um valor e um ponteiro para o pr√≥ximo<br>
                <strong>Explica√ß√£o:</strong> Listas encadeadas usam ponteiros para conectar os n√≥s, n√£o armazenam dados em posi√ß√µes cont√≠nuas.
            </div>

            <div class="question">
                <h4>2. Qual √© a principal vantagem das listas encadeadas em rela√ß√£o a vetores?</h4>
                <p>a) Acesso direto por √≠ndice</p>
                <p>b) Inser√ß√£o e remo√ß√£o eficientes em qualquer posi√ß√£o</p>
                <p>c) Uso de menos mem√≥ria</p>
                <p>d) Armazenamento sequencial de dados</p>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> b) Inser√ß√£o e remo√ß√£o eficientes em qualquer posi√ß√£o<br>
                <strong>Explica√ß√£o:</strong> Vetores t√™m custo alto para inser√ß√£o/remo√ß√£o no meio, listas encadeadas s√£o mais eficientes.
            </div>

            <div class="question">
                <h4>3. O que acontece com o ponteiro de uma lista quando ela est√° vazia?</h4>
                <p>a) Aponta para o valor 1</p>
                <p>b) √â igual ao valor 0</p>
                <p>c) Recebe NULL</p>
                <p>d) Aponta para o fim da mem√≥ria</p>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> c) Recebe NULL<br>
                <strong>Explica√ß√£o:</strong> NULL indica que n√£o h√° elementos na lista.
            </div>

            <div class="question">
                <h4>4. Qual fun√ß√£o da linguagem C √© usada para alocar mem√≥ria dinamicamente?</h4>
                <p>a) calloc()</p>
                <p>b) realloc()</p>
                <p>c) malloc()</p>
                <p>d) assign()</p>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> c) malloc()<br>
                <strong>Explica√ß√£o:</strong> malloc() √© a fun√ß√£o padr√£o para aloca√ß√£o din√¢mica de mem√≥ria.
            </div>

            <div class="question">
                <h4>5. O que a fun√ß√£o free() faz em listas?</h4>
                <p>a) Copia um n√≥</p>
                <p>b) Cria um n√≥</p>
                <p>c) Libera a mem√≥ria alocada</p>
                <p>d) Retorna o valor de um n√≥</p>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> c) Libera a mem√≥ria alocada<br>
                <strong>Explica√ß√£o:</strong> free() √© essencial para evitar vazamentos de mem√≥ria.
            </div>

            <div class="question">
                <h4>6. O que significa FIFO?</h4>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> First In, First Out (primeiro a entrar, primeiro a sair)<br>
                <strong>Explica√ß√£o:</strong> Princ√≠pio fundamental das filas.
            </div>

            <div class="question">
                <h4>7. Em um vetor de 10 posi√ß√µes, qual √© o √≠ndice do √∫ltimo elemento?</h4>
                <p>a) 10</p>
                <p>b) 9</p>
                <p>c) 8</p>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> b) 9<br>
                <strong>Explica√ß√£o:</strong> √çndices come√ßam em 0, ent√£o o √∫ltimo elemento tem √≠ndice 9.
            </div>

            <div class="question">
                <h4>8. Qual estrutura permite armazenar dados em linhas e colunas?</h4>
                <p>a) Array unidimensional</p>
                <p>b) Fila</p>
                <p>c) Matriz</p>
                <p>d) Lista encadeada</p>
            </div>
            <div class="answer">
                <strong>Resposta:</strong> c) Matriz<br>
                <strong>Explica√ß√£o:</strong> Matrizes s√£o estruturas bidimensionais.
            </div>
        </div>

        <!-- 8. RESUMO EXECUTIVO -->
        <div id="resumo" class="section">
            <h2>8. RESUMO EXECUTIVO</h2>
            
            <h3>Compara√ß√£o de Estruturas</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Estrutura</th>
                        <th>Princ√≠pio</th>
                        <th>Opera√ß√µes</th>
                        <th>Vantagens</th>
                        <th>Desvantagens</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Vetor</td>
                        <td>Acesso Direto</td>
                        <td>Inser√ß√£o/Remo√ß√£o</td>
                        <td>Acesso r√°pido</td>
                        <td>Tamanho fixo</td>
                    </tr>
                    <tr>
                        <td>Lista Encadeada</td>
                        <td>Ponteiros</td>
                        <td>Inser√ß√£o/Remo√ß√£o</td>
                        <td>Tamanho din√¢mico</td>
                        <td>Sem acesso direto</td>
                    </tr>
                    <tr>
                        <td>Pilha</td>
                        <td>LIFO</td>
                        <td>Push/Pop</td>
                        <td>Simples</td>
                        <td>Acesso limitado</td>
                    </tr>
                    <tr>
                        <td>Fila</td>
                        <td>FIFO</td>
                        <td>Enqueue/Dequeue</td>
                        <td>Ordem garantida</td>
                        <td>Acesso limitado</td>
                    </tr>
                </tbody>
            </table>

            <h3>Quest√µes Mais Comuns</h3>
            <div class="highlight">
                <ul>
                    <li>O que caracteriza uma lista encadeada? ‚Üí Cada n√≥ tem valor + ponteiro</li>
                    <li>Qual a vantagem de listas vs vetores? ‚Üí Inser√ß√£o/remo√ß√£o eficiente</li>
                    <li>O que significa FIFO? ‚Üí First In, First Out</li>
                    <li>O que significa LIFO? ‚Üí Last In, First Out</li>
                    <li>Qual fun√ß√£o aloca mem√≥ria? ‚Üí malloc()</li>
                    <li>Qual fun√ß√£o libera mem√≥ria? ‚Üí free()</li>
                    <li>√çndice do √∫ltimo elemento em vetor de 10? ‚Üí 9</li>
                    <li>Ponteiro de lista vazia? ‚Üí NULL</li>
                </ul>
            </div>

            <h3>Dicas para a Prova</h3>
            <div class="tip">
                <ul>
                    <li>Memorize LIFO (pilhas) e FIFO (filas)</li>
                    <li>Entenda diferen√ßas entre estruturas est√°ticas e din√¢micas</li>
                    <li>Pratique implementa√ß√µes b√°sicas em C</li>
                    <li>Aten√ß√£o aos ponteiros e NULL</li>
                    <li>Revise vantagens/desvantagens de cada estrutura</li>
                    <li>Teste casos extremos (vazio, um elemento, cheio)</li>
                    <li>Sempre libere mem√≥ria com free()</li>
                    <li>Use m√≥dulo (%) em filas circulares</li>
                </ul>
            </div>

            <div class="success">
                <h3>üéØ DICAS FINAIS DE IMPLEMENTA√á√ÉO</h3>
                <ul>
                    <li>Sempre verifique se a estrutura est√° vazia antes de remover elementos</li>
                    <li>Em filas circulares, use m√≥dulo (%) para calcular √≠ndices</li>
                    <li>Sempre libere mem√≥ria alocada dinamicamente com free()</li>
                    <li>Use ponteiros para modificar estruturas dentro de fun√ß√µes</li>
                    <li>Teste casos extremos: lista vazia, um elemento, muitos elementos</li>
                </ul>
            </div>

            <div class="important">
                <h3>‚ö†Ô∏è PONTOS CR√çTICOS PARA A PROVA</h3>
                <ul>
                    <li><strong>LIFO vs FIFO:</strong> Entenda a diferen√ßa fundamental</li>
                    <li><strong>Ponteiros:</strong> NULL indica fim da lista ou lista vazia</li>
                    <li><strong>malloc/free:</strong> Sempre libere mem√≥ria alocada</li>
                    <li><strong>√çndices:</strong> Come√ßam em 0, √∫ltimo elemento = tamanho-1</li>
                    <li><strong>Estruturas:</strong> Vetores vs Listas vs Pilhas vs Filas</li>
                </ul>
            </div>
        </div>

        <div style="text-align: center; margin: 40px 0; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 10px;">
            <h2>üçÄ BOA SORTE NA PROVA! üçÄ</h2>
            <p>Voc√™ est√° preparado! Revise este material e confie no seu conhecimento.</p>
        </div>
    </div>

    <script>
        function scrollToSection(sectionId) {
            const element = document.getElementById(sectionId);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Adicionar funcionalidade de busca
        function searchContent() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const sections = document.querySelectorAll('.section');
            
            sections.forEach(section => {
                const text = section.textContent.toLowerCase();
                if (text.includes(searchTerm)) {
                    section.style.display = 'block';
                    section.style.backgroundColor = searchTerm ? '#fff3cd' : 'white';
                } else if (searchTerm) {
                    section.style.display = 'none';
                } else {
                    section.style.display = 'block';
                    section.style.backgroundColor = 'white';
                }
            });
        }

        // Adicionar campo de busca
        const searchDiv = document.createElement('div');
        searchDiv.innerHTML = `
            <div style="margin: 20px 0; text-align: center;">
                <input type="text" id="searchInput" placeholder="üîç Buscar no material..." 
                       style="padding: 10px; width: 300px; border: 2px solid #3498db; border-radius: 5px; font-size: 16px;">
                <button onclick="searchContent()" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; margin-left: 10px; cursor: pointer;">
                    Buscar
                </button>
            </div>
        `;
        document.querySelector('.container').insertBefore(searchDiv, document.querySelector('.toc'));
    </script>
</body>
</html> 